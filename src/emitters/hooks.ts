// test hook trigger
import type { ProjectConfig } from "../config/schema.js";
import type { Hook, HookEvent } from "../domain/hook.js";
import type { IgnorePattern } from "../domain/ignore-pattern.js";
import type { EmitResult, EmittedFile, Emitter, TargetTool } from "./types.js";

/** Maps internal hook event names to Claude Code's PascalCase event names. */
const CLAUDE_EVENT_MAP: Partial<Record<HookEvent, string>> = {
	preToolUse: "PreToolUse",
	postToolUse: "PostToolUse",
	sessionStart: "SessionStart",
	sessionEnd: "SessionEnd",
	userPromptSubmitted: "UserPromptSubmit",
	agentStop: "Stop",
	subagentStop: "SubagentStop",
};

/** Emits hooks and ignore pattern configuration files. */
export const hooksEmitter: Emitter = {
	emit(config: ProjectConfig, target: TargetTool): EmitResult {
		switch (target) {
			case "claude":
				return emitClaude(config.hooks, config.ignorePatterns);
			case "cursor":
				return emitCursor(config.hooks, config.ignorePatterns);
			case "codex":
				return emitCodex(config.hooks, config.ignorePatterns);
			case "copilot":
				return emitCopilot(config.hooks, config.ignorePatterns);
		}
	},
};

/** Claude Code: hooks in settings.json, ignore as deny rules on Read/Edit */
function emitClaude(hooks: Hook[], ignorePatterns: IgnorePattern[]): EmitResult {
	const files: EmittedFile[] = [];
	const warnings: string[] = [];

	if (hooks.length === 0 && ignorePatterns.length === 0) return { files, warnings };

	const settings: Record<string, unknown> = {};

	// Hooks — Claude Code format:
	// { "Event": [{ "matcher": "ToolName", "hooks": [{ "type": "command", "command": "..." }] }] }
	if (hooks.length > 0) {
		const hooksObj: Record<string, unknown[]> = {};
		for (const hook of hooks) {
			const claudeEvent = CLAUDE_EVENT_MAP[hook.event];
			if (!claudeEvent) {
				warnings.push(`Hook event "${hook.event}" is not supported by Claude Code — skipped.`);
				continue;
			}
			if (!hooksObj[claudeEvent]) hooksObj[claudeEvent] = [];
			const entry: Record<string, unknown> = {
				hooks: [{ type: "command", command: hook.handler }],
			};
			if (hook.matcher) entry.matcher = hook.matcher;
			hooksObj[claudeEvent].push(entry);
		}
		settings.hooks = hooksObj;
	}

	// Ignore patterns as deny rules
	if (ignorePatterns.length > 0) {
		const deny = ignorePatterns.flatMap((p) => [`Read(${p.pattern})`, `Edit(${p.pattern})`]);
		settings.permissions = { deny };
	}

	files.push({
		path: ".claude/settings.json",
		content: `${JSON.stringify(settings, null, 2)}\n`,
	});

	return { files, warnings };
}

/** Cursor: ignore patterns → .cursorignore, hooks not directly emitted */
function emitCursor(hooks: Hook[], ignorePatterns: IgnorePattern[]): EmitResult {
	const files: EmittedFile[] = [];
	const warnings: string[] = [];

	if (ignorePatterns.length > 0) {
		const lines = [
			"# Generated by dotai",
			"# File exclusion rules for Cursor AI",
			"",
			...ignorePatterns.map((p) => p.pattern),
			"",
		];
		files.push({
			path: ".cursorignore",
			content: lines.join("\n"),
		});
	}

	if (hooks.length > 0) {
		warnings.push(
			"Cursor hook support is limited — hooks are not directly emitted to Cursor config.",
		);
	}

	return { files, warnings };
}

/** Codex: ignore → protected paths in config.toml, hooks not supported */
function emitCodex(hooks: Hook[], ignorePatterns: IgnorePattern[]): EmitResult {
	const files: EmittedFile[] = [];
	const warnings: string[] = [];

	if (ignorePatterns.length > 0) {
		const paths = ignorePatterns.map((p) => `"${p.pattern}"`).join(", ");
		files.push({
			path: ".codex/config.toml",
			content: `protected_paths = [${paths}]\n`,
		});
	}

	if (hooks.length > 0) {
		warnings.push("Codex does not support hooks — hook configuration is skipped.");
	}

	return { files, warnings };
}

/** Events supported by Copilot hooks. */
const COPILOT_HOOK_EVENTS = new Set([
	"preToolUse",
	"postToolUse",
	"sessionStart",
	"sessionEnd",
	"userPromptSubmitted",
	"agentStop",
	"subagentStop",
	"errorOccurred",
]);

/** Copilot: .github/hooks/dotai.hooks.json */
function emitCopilot(hooks: Hook[], ignorePatterns: IgnorePattern[]): EmitResult {
	const files: EmittedFile[] = [];
	const warnings: string[] = [];

	if (hooks.length > 0) {
		const hooksObj: Record<string, unknown[]> = {};
		for (const hook of hooks) {
			if (!COPILOT_HOOK_EVENTS.has(hook.event)) {
				warnings.push(`Hook event "${hook.event}" is not supported by Copilot — skipped.`);
				continue;
			}
			if (!hooksObj[hook.event]) hooksObj[hook.event] = [];
			const entry: Record<string, unknown> = { command: hook.handler };
			if (hook.matcher) entry.matcher = hook.matcher;
			hooksObj[hook.event].push(entry);
		}

		if (Object.keys(hooksObj).length > 0) {
			files.push({
				path: ".github/hooks/dotai.hooks.json",
				content: `${JSON.stringify({ hooks: hooksObj }, null, 2)}\n`,
			});
		}
	}

	if (ignorePatterns.length > 0) {
		warnings.push(
			"Copilot does not support file-based ignore patterns — ignore configuration is skipped.",
		);
	}

	return { files, warnings };
}
