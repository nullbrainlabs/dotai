// test hook trigger
import type { ProjectConfig } from "../config/schema.js";
import type { Hook, HookEvent } from "../domain/hook.js";
import type { IgnorePattern } from "../domain/ignore-pattern.js";
import type { EmitResult, EmittedFile, Emitter, TargetTool } from "./types.js";

/** Maps internal hook event names to Claude Code's PascalCase event names. */
const CLAUDE_EVENT_MAP: Partial<Record<HookEvent, string>> = {
	preToolUse: "PreToolUse",
	postToolUse: "PostToolUse",
	sessionStart: "SessionStart",
	sessionEnd: "SessionEnd",
	userPromptSubmitted: "UserPromptSubmit",
	agentStop: "Stop",
	subagentStop: "SubagentStop",
	permissionRequest: "PermissionRequest",
	postToolUseFailure: "PostToolUseFailure",
	notification: "Notification",
	subagentStart: "SubagentStart",
	teammateIdle: "TeammateIdle",
	taskCompleted: "TaskCompleted",
	configChange: "ConfigChange",
	worktreeCreate: "WorktreeCreate",
	worktreeRemove: "WorktreeRemove",
	preCompact: "PreCompact",
};

/** Emits hooks and ignore pattern configuration files. */
export const hooksEmitter: Emitter = {
	emit(config: ProjectConfig, target: TargetTool): EmitResult {
		switch (target) {
			case "claude":
				return emitClaude(config.hooks, config.ignorePatterns);
			case "cursor":
				return emitCursor(config.hooks, config.ignorePatterns);
			case "codex":
				return emitCodex(config.hooks, config.ignorePatterns);
			case "copilot":
				return emitCopilot(config.hooks, config.ignorePatterns);
		}
	},
};

/** Claude Code: hooks in settings.json, ignore as deny rules on Read/Edit */
function emitClaude(hooks: Hook[], ignorePatterns: IgnorePattern[]): EmitResult {
	const files: EmittedFile[] = [];
	const warnings: string[] = [];

	if (hooks.length === 0 && ignorePatterns.length === 0) return { files, warnings };

	const settings: Record<string, unknown> = {
		$schema: "https://json.schemastore.org/claude-code-settings.json",
	};

	// Hooks — Claude Code format:
	// { "Event": [{ "matcher": "ToolName", "hooks": [{ ... }] }] }
	if (hooks.length > 0) {
		const hooksObj: Record<string, unknown[]> = {};
		for (const hook of hooks) {
			const claudeEvent = CLAUDE_EVENT_MAP[hook.event];
			if (!claudeEvent) {
				warnings.push(`Hook event "${hook.event}" is not supported by Claude Code — skipped.`);
				continue;
			}
			if (!hooksObj[claudeEvent]) hooksObj[claudeEvent] = [];
			const entry: Record<string, unknown> = {
				hooks: [buildClaudeHookHandler(hook)],
			};
			if (hook.matcher) entry.matcher = hook.matcher;
			hooksObj[claudeEvent].push(entry);
		}
		settings.hooks = hooksObj;
	}

	// Ignore patterns as deny rules
	if (ignorePatterns.length > 0) {
		const deny = ignorePatterns.flatMap((p) => [`Read(${p.pattern})`, `Edit(${p.pattern})`]);
		settings.permissions = { deny };
	}

	files.push({
		path: ".claude/settings.json",
		content: `${JSON.stringify(settings, null, 2)}\n`,
	});

	return { files, warnings };
}

/** Build a Claude Code hook handler object based on hook type and fields. */
function buildClaudeHookHandler(hook: Hook): Record<string, unknown> {
	const hookType = hook.type ?? "command";
	const handler: Record<string, unknown> = {};

	if (hookType === "command") {
		handler.type = "command";
		handler.command = hook.handler;
		if (hook.async) handler.async = true;
	} else if (hookType === "prompt") {
		handler.type = "prompt";
		handler.prompt = hook.handler;
	} else if (hookType === "agent") {
		handler.type = "agent";
		handler.prompt = hook.handler;
	}

	if (hook.timeout !== undefined) handler.timeout = hook.timeout;
	if (hook.statusMessage) handler.statusMessage = hook.statusMessage;
	if (hook.once) handler.once = true;
	if (hook.model && (hookType === "prompt" || hookType === "agent")) handler.model = hook.model;

	return handler;
}

/** Cursor: ignore patterns → .cursorignore, hooks not directly emitted */
function emitCursor(hooks: Hook[], ignorePatterns: IgnorePattern[]): EmitResult {
	const files: EmittedFile[] = [];
	const warnings: string[] = [];

	if (ignorePatterns.length > 0) {
		const lines = [
			"# Generated by dotai",
			"# File exclusion rules for Cursor AI",
			"",
			...ignorePatterns.map((p) => p.pattern),
			"",
		];
		files.push({
			path: ".cursorignore",
			content: lines.join("\n"),
		});
	}

	if (hooks.length > 0) {
		warnings.push(
			"Cursor hook support is limited — hooks are not directly emitted to Cursor config.",
		);
	}

	return { files, warnings };
}

/** Codex: ignore → protected paths in config.toml, hooks not supported */
function emitCodex(hooks: Hook[], ignorePatterns: IgnorePattern[]): EmitResult {
	const files: EmittedFile[] = [];
	const warnings: string[] = [];

	if (ignorePatterns.length > 0) {
		const paths = ignorePatterns.map((p) => `"${p.pattern}"`).join(", ");
		files.push({
			path: ".codex/config.toml",
			content: `protected_paths = [${paths}]\n`,
		});
	}

	if (hooks.length > 0) {
		warnings.push("Codex does not support hooks — hook configuration is skipped.");
	}

	return { files, warnings };
}

/** Events supported by Copilot hooks. */
const COPILOT_HOOK_EVENTS = new Set([
	"sessionStart",
	"sessionEnd",
	"userPromptSubmitted",
	"preToolUse",
	"postToolUse",
	"errorOccurred",
	"agentStop",
	"subagentStop",
]);

/** Copilot: .github/hooks/hooks.json — version 1 format */
function emitCopilot(hooks: Hook[], ignorePatterns: IgnorePattern[]): EmitResult {
	const files: EmittedFile[] = [];
	const warnings: string[] = [];

	if (hooks.length > 0) {
		const hooksObj: Record<string, unknown[]> = {};
		for (const hook of hooks) {
			if (!COPILOT_HOOK_EVENTS.has(hook.event)) {
				warnings.push(`Hook event "${hook.event}" is not supported by Copilot — skipped.`);
				continue;
			}
			const hookType = hook.type ?? "command";
			if (hookType !== "command") {
				warnings.push(
					`Hook type "${hookType}" is not supported by Copilot — only "command" hooks are supported. Skipped.`,
				);
				continue;
			}

			if (!hooksObj[hook.event]) hooksObj[hook.event] = [];
			const entry: Record<string, unknown> = {
				type: "command",
				bash: hook.handler,
			};
			if (hook.timeout !== undefined) entry.timeoutSec = Math.round(hook.timeout / 1000);
			if (hook.statusMessage) entry.comment = hook.statusMessage;
			if (hook.cwd) entry.cwd = hook.cwd;
			if (hook.env && Object.keys(hook.env).length > 0) entry.env = hook.env;
			hooksObj[hook.event].push(entry);
		}

		if (Object.keys(hooksObj).length > 0) {
			files.push({
				path: ".github/hooks/hooks.json",
				content: `${JSON.stringify({ version: 1, hooks: hooksObj }, null, 2)}\n`,
			});
		}
	}

	if (ignorePatterns.length > 0) {
		warnings.push(
			"Copilot does not support file-based ignore patterns — ignore configuration is skipped.",
		);
	}

	return { files, warnings };
}
